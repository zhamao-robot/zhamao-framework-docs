(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{804:function(e,v,r){"use strict";r.r(v);var _=r(108),s=Object(_.a)({},(function(){var e=this,v=e.$createElement,r=e._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"框架常见问题-持续更新"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#框架常见问题-持续更新"}},[e._v("#")]),e._v(" 框架常见问题（持续更新）")]),e._v(" "),r("h2",{attrs:{id:"如何正确地强制退出炸毛框架"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何正确地强制退出炸毛框架"}},[e._v("#")]),e._v(" 如何正确地强制退出炸毛框架？")]),e._v(" "),r("p",[e._v("首先要知道一个概念，炸毛框架和传统的 PHP 以及其他如 Python 等语言的轻量框架都不同，框架启动后会依次启动 Master、Manager、Worker 等多个进程，而用户启动时入口的 PHP 进程就是 Master 进程，在一些对框架的正常中止、热重启上，我们给 Master 进程发送相应的 Linux 信号（如 SIGTERM）即可对整个框架的多个进程生效，无需给每个进程发送。")]),e._v(" "),r("p",[e._v("但是如果因为用户的误操作，导致炸毛框架其中的一个或多个进程阻塞，或者比如将框架挂在 screen 等守护但是守护服务进程被杀掉，总之就是无法使用 Ctrl+C 的方式正常关闭框架，这时就需要正确地杀掉所有框架进程（这固然可能会造成内存的缓存数据丢失）。")]),e._v(" "),r("h3",{attrs:{id:"v2-7-0-及以上版本教程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v2-7-0-及以上版本教程"}},[e._v("#")]),e._v(" v2.7.0 及以上版本教程")]),e._v(" "),r("ul",[r("li",[e._v("安全关框架指令："),r("code",[e._v("./zhamao server:stop")])]),e._v(" "),r("li",[e._v("万能杀死所有框架进程指令："),r("code",[e._v("./zhamao server:stop --force")])]),e._v(" "),r("li",[e._v("监视框架是否在运行："),r("code",[e._v("./zhamao server:status")])]),e._v(" "),r("li",[e._v("Worker 进程卡死：连续按 5 次 Ctrl+C 即可强行杀掉所有进程（SIGKILL）")])]),e._v(" "),r("h3",{attrs:{id:"v2-6-6-及以下版本教程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v2-6-6-及以下版本教程"}},[e._v("#")]),e._v(" v2.6.6 及以下版本教程")]),e._v(" "),r("div",{staticClass:"custom-block warning"},[r("p",{staticClass:"custom-block-title"},[e._v("注意")]),e._v(" "),r("p",[e._v("下方涉及 "),r("code",[e._v("ps")]),e._v(" 命令后使用 "),r("code",[e._v("grep")]),e._v(" 过滤的框架进程方式，如果你的服务器同时有其他使用 PHP 启动的服务，命令行刚好有 "),r("code",[e._v("server")]),e._v(" 字样，可能会导致误杀，如果有影响的话，建议将 "),r("code",[e._v("grep server")]),e._v(" 换成你启动时命令行的特殊参数或手动排除！")])]),e._v(" "),r("p",[e._v("**一、**首先，使用 "),r("code",[e._v("ps")]),e._v("、"),r("code",[e._v("htop")]),e._v("、"),r("code",[e._v("netstat -nlp")]),e._v(" 等命令确定框架的入口进程（也就是 Master 进程的 pid）。")]),e._v(" "),r("p",[e._v("确认方式示例如下：")]),e._v(" "),r("ul",[r("li",[e._v("如果你使用的是 >=2.4 版本的框架，在框架启动时就会在最先开始的 motd 上方显示 "),r("code",[e._v("master_pid")]),e._v("，如果你还能找到此处的显示，那么恭喜你，可以直接进行下面的第二步。")]),e._v(" "),r("li",[e._v("如果你不能正常通过框架的方式找到 pid，可以通过命令 "),r("code",[e._v("ps aux | grep php | grep server")]),e._v(" 的方式找到框架所有的进程。其中列出的相关框架的进程，可以寻找 pid 最小的进程，即为 Master 进程。关于如何区分进程对应关系，见本页 "),r("a",{attrs:{href:""}},[e._v("使用 Linux 工具辨别框架进程")]),e._v("。")]),e._v(" "),r("li",[e._v("如果你对 "),r("code",[e._v("ps")]),e._v(" 不熟悉，可以使用 "),r("code",[e._v("htop")]),e._v(" 工具，使用 "),r("code",[e._v("F5 Tree")]),e._v(" 方式显示，并且使用 "),r("code",[e._v("F4")]),e._v(" 的 Filter，过滤 "),r("code",[e._v("php")]),e._v(" 或 "),r("code",[e._v("bin/start")]),e._v(" 等字样，找到进程树。")])]),e._v(" "),r("p",[e._v("**二、**然后，确定框架是否正常运行且正常流程关闭。")]),e._v(" "),r("p",[e._v("如果框架能正常运行，比如可以通过访问浏览器的 "),r("code",[e._v("http://地址:端口/httpTimer")]),e._v(" 等 HTTP 路由，可以使用 "),r("code",[e._v("SIGINT")]),e._v(" 或 "),r("code",[e._v("SIGTERM")]),e._v(" 信号正常关闭框架。我们假设 Master 进程的 pid 为 31234："),r("code",[e._v("kill -TERM 31234")]),e._v(" 或 "),r("code",[e._v("kill -INT 31234")]),e._v("，如果稍后使用 "),r("code",[e._v("ps aux | grep php | grep server")]),e._v(" 命令发现没有进程存在（排除掉 grep 自身的进程），说明可以正常关闭，此关闭方法为正常停止流程，即保存了 "),r("code",[e._v("LightCache")]),e._v(" 等内存缓存持久化的数据。")]),e._v(" "),r("p",[e._v("如果以上方式没有任何效果，继续看第三步。")]),e._v(" "),r("p",[e._v("**三、**不能正常流程关闭，需要手动杀掉所有进程。")]),e._v(" "),r("p",[e._v("首先使用 "),r("code",[e._v("ps aux | grep php | grep server | grep -v grep | awk '{print $2}'")]),e._v(" 列出框架所有进程的 pid，确认无误后，在此条命令后接 "),r("code",[e._v("| xargs kill -9")]),e._v(" 即可：")]),e._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 列出进程，只显示包含php，只显示包含server，排除grep本身进程，显示第二列的pid，使用xargs循环kill这里面的进程")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("ps")]),e._v(" aux "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("grep")]),e._v(" php "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("grep")]),e._v(" server "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("grep")]),e._v(" -v "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("grep")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("awk")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v("'{print $2}'")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("xargs")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("kill")]),e._v(" -9\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br")])]),r("h2",{attrs:{id:"如何使用-linux-工具查看框架进程状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-linux-工具查看框架进程状态"}},[e._v("#")]),e._v(" 如何使用 Linux 工具查看框架进程状态？")]),e._v(" "),r("p",[e._v("框架有多个进程，有时候我们需要通过监视进程状态来确定框架是否正常运行或查看框架的资源占用率。首先一个大概念，老生常谈，炸毛框架由 Master、Manager、Worker（、TaskWorker）进程组成的。")]),e._v(" "),r("p",[e._v("如果使用 htop 工具，就比较简单，比如我启动了一个应用，使用炸毛框架编写的垃圾分类小程序 API 服务器，在 htop 命令后找到如图这部分（下面的树状图是按 F5 后切换为树状显示，避免进程刷太快可以输入 "),r("code",[e._v("Shift+z")]),e._v("）：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.zhamao.me/images/docs/image-20210708003903652.png",alt:"image-20210708003903652"}})]),e._v(" "),r("p",[e._v("其中，"),r("code",[e._v("-zsh")]),e._v(" 下有唯一一个 php 进程，在图中对应的第一列 pid 为 "),r("code",[e._v("16258")]),e._v("，代表 Master 进程。")]),e._v(" "),r("p",[e._v("Master 进程下的唯一一个子进程（白色的是进程，绿色是线程），在图中对应的 pid 为 "),r("code",[e._v("16263")]),e._v("，代表 Manager 进程，用作管理 Worker 进程。")]),e._v(" "),r("p",[e._v("Manager 进程下的子进程，连号部分为对应的 Worker 进程，比如图中的 "),r("code",[e._v("16266")]),e._v("，"),r("code",[e._v("16267")]),e._v("，"),r("code",[e._v("16268")]),e._v("，"),r("code",[e._v("16269")]),e._v(" 分别代表 "),r("code",[e._v("Worker #0")]),e._v("，"),r("code",[e._v("Worker #1")]),e._v("，"),r("code",[e._v("Worker #2")]),e._v("，"),r("code",[e._v("Worker #3")]),e._v(" 四个 Worker 进程。")]),e._v(" "),r("p",[e._v("如果你还设置了 TaskWorker 进程，TaskWorker 进程的 pid 会和 Worker 进程一样是连续的，一般会接在 Worker 进程后面。")]),e._v(" "),r("p",[r("code",[e._v("htop")]),e._v(" 使用方向键选择进程，选择到对应进程后可以使用 "),r("code",[e._v("F9")]),e._v(" 来选择 kill 指令，比如让框架热重启，可以将光标移到 Master 进程上，使用 "),r("code",[e._v("SIGUSR1")]),e._v("：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://static.zhamao.me/images/docs/image-20210708004921655.png",alt:"image-20210708004921655"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);